# preferences
dat   <- read_rds("99_ObservedMovements.rds")
cov   <- read_rds("99_CovariateLayers.rds")
nps   <- read_rds("99_NationalParks.rds")
truth <- read_rds("99_TruePreferences.rds")
# Make sure covariate layers are loaded into memory for quicker compuations on
# the layers.
cov <- readAll(cov)
inMemory(cov)
# How many GPS observations are there?
nrow(dat)
# How many observations per individual?
table(dat$ID)
# Visualize covariates and the collected GPS data
cov %>%
as.data.frame(xy = T) %>%
gather(key = covariate, value = value, 3:ncol(.)) %>%
ggplot() +
geom_raster(aes(x = x, y = y, fill = value)) +
geom_point(data = dat, inherit.aes = F, aes(x = x, y = y, col = ID), size = 0.1) +
geom_path(data = dat, inherit.aes = F, aes(x = x, y = y, col = ID), size = 0.1) +
geom_sf(data = st_as_sf(nps), col = "white", fill = NA) +
geom_sf_text(data = st_as_sf(nps), aes(label = ParkName), col = "white"
, nudge_y = 10, size = 3) +
facet_wrap("covariate") +
scale_fill_viridis_c(option = "magma") +
theme_minimal() +
coord_sf() +
theme(legend.position = "none")
################################################################################
#### Step Selection Function
################################################################################
# Nest the data by individual and coerce data to amt-tracks. We generate one
# track per individual.
dat_track <- dat %>%
nest(data = -ID) %>%
mutate(track = map(data, function(x){
suppressMessages(
make_track(x, .x = x, .y = y, .t = timestamp
, step_number = step_number, step_id = step_id)
)
}))
# Let's see how this looks like.
print(dat_track)
# What's the sampling rate (in hours) of the GPS data?
sapply(dat_track$track, summarize_sampling_rate, time_unit = "hour")
# It looks like the data was collected at a resolution of 1 fix per hour. Hence,
# let's identify bursts where the fixes are not separated by more than one hour
# (+- 15 minutes of tolerance). We then also remove bursts with fewer than two
# consequcitve relocations
dat_track <- mutate(dat_track, track = map(track, function(x){
temp <- track_resample(x, rate = hours(1), tolerance = minutes(15))
temp <- filter_min_n_burst(temp, 2)
return(temp)
}))
# We can now move from a point to a step representation. That is, we convert
# consecutive relocations into a line.
dat_track <- mutate(dat_track, track = map(track, function(x){
steps_by_burst(x)
}))
# Unnest the steps so that we can fit distributions to step lengths and turning
# angles (we will use the same distributions for all individuals)
unnested <- dat_track %>%
select(ID, track) %>%
unnest(track) %>%
select(ta_, sl_)
# Visualize distributions for turning angles and step lengths
hist(unnested$sl_, breaks = 30, main = "Step Length Distribution", xlab = "Step Length")
hist(unnested$ta_, breaks = 30, main = "Turning Angle Distribution", xlab = "Turning Angle")
# We can actually fit the scale and shape parameters of the gamma distribution
# and the concentration parameter of the vonmises distribution
sl_dist <- fit_distr(unnested$sl_, dist_name = "gamma")
ta_dist <- fit_distr(unnested$ta_, dist_name = "vonmises")
# Check the parameters of the fitted distributions. Note that the value of kappa
# is close to beta_cos_ta (= 1). This is exactly what Avgar et al. 2016 showed!
sl_dist
ta_dist
# However, Avgar et al. 2016 suggest to use a uniform distribution (i.e. a von
# Mises distribution with kappa = 0) for the turning angles when proposing
# random steps. Hence, we'll force kappa to 0
ta_dist$params$kappa <- 0
# We don't need the unnested data anymore and remove it
rm(unnested)
# We can now use the distributions to generate random steps. That is, for each
# "observed" or "realized" step, we now generate a set of 25 alternative steps.
# To generate said steps, we sample step lengths and turning angles from the
# specified distributions.
dat_track <- mutate(dat_track, ssf = map(track, function(x){
random_steps(x
, n_control = 25
, sl_distr  = sl_dist
, ta_distr  = ta_dist
)
}))
# Unnest the steps (observed + random)
ssf <- dat_track %>%
select(ID, ssf) %>%
unnest(ssf)
# Compute the cosine of each relative turning angle -> cos_ta
ssf$cos_ta <- cos(ssf$ta_)
# Note that step_id_ is currently not unique across individuals as it was.
# Hence, we replace it with a unique identifier so that each stratum (a realized
# step + its 25 random steps) gets a unique identiier.
ssf <- ssf %>%
group_by(ID, step_id_) %>%
mutate(step_id = cur_group_id()) %>%
ungroup() %>%
select(-step_id_)
# Finally, we extract covariates along each step and calculate average values
# along the steps and bind the extracted data to the respective step. On windows
# machines, this will throw a warning which you can ignore.
extracted <- extract_covariates_along_interpolated(ssf, cov, by = 0.1)
ssf <- cbind(ssf, extracted)
################################################################################
#### Estimate Beta
################################################################################
# Now we can contrast realized and random steps using conditional logistic
# regression analysis. For simplicity, we do not consider random effects (in our
# case individuals have the same preferences anyways). However, if you're
# interested on how to fit a mixed effects conditional logistic regression,
# check Fieberg et al 2020
mod <- fit_clogit(case_ ~
+ elev
+ dist
+ cos_ta
+ strata(step_id)
, data = ssf
)
# Check the summary and extract the coefficients
summary(mod)
beta_cl <- coef(mod)
# Visualize the model and add the true preferences for comparison
ggplot(tidy(mod$model), aes(x = estimate, y = term)) +
geom_point() +
geom_errorbarh(aes(
xmin = estimate - 1.96 * std.error
, xmax = estimate + 1.96 * std.error)
, height = 0.1
) +
geom_point(data = truth, inherit.aes = F, aes(x = Coefficient, y = Covariate)
, col = "red", pch = 8, size = 3) +
theme_classic() +
geom_vline(xintercept = 0, linetype = 2)
# It appears that the model picks up the preferences correctly. Increasing the
# number of simulated individuals would of course improve estimates.
cbind(truth, beta_cl)
# Store the estimated preferences to a file.
results <- data.frame(
Coefficient = names(beta_cl)
, Estimate    = beta_cl
)
rownames(results) <- NULL
write_rds(results, "99_Estimates.rds")
# We also want to keep track of the step length and turn angle distirbutions
write_rds(sl_dist, "99_StepLengthDistribution.rds")
write_rds(ta_dist, "99_TurningAngleDistribution.rds")
################################################################################
#### Dispersal Simulation
################################################################################
# Description: Based on derived selection coefficients, we now simulate
# dispersers moving across the study area.
# Clear R's brain
rm(list = ls())
# Load required packages
library(tidyverse)      # For data wrangling
library(raster)         # To handle spatial data
library(viridis)        # For nice colors
library(rgdal)          # To load shapefiles
library(rgeos)          # For geometry manipulation
library(foreach)        # For parallel computing (on windows)
library(doSNOW)         # For parallel computing (on windows)
library(parallel)       # For parallel computing (on windows)
library(sf)             # To plot spatial things with ggplot
# # Set working directory
# setwd("/home/david/ownCloud/DispersalSimulation")
# Load custom functions
source("00_Functions.R")
# Load covariate layers
cov <- read_rds("99_CovariateLayers.rds")
nps <- read_rds("99_NationalParks.rds")
# Load estimated coefficients and step-length & turning angle distributions
beta    <- read_rds("99_Estimates.rds")
sl_dist <- read_rds("99_StepLengthDistribution.rds")
ta_dist <- read_rds("99_TurningAngleDistribution.rds")
# Make sure covariate layers are loaded into memory for maximal efficiency
cov <- readAll(cov)
inMemory(cov)
# Create a polygon for the extent of the study area
ext <- extent(cov)
ext <- as(ext, "SpatialPolygons")
# Define area on which simulated individuals are allowed to move. Note that we
# allow virtual dispersers to move through the buffer zone.
ext_move <- extent(-20, 120, -20, 120)
ext_move <- as(ext_move, "SpatialPolygons")
# Visualize covariates
cov %>%
as.data.frame(xy = T) %>%
gather(key = covariate, value = value, 3:ncol(.)) %>%
ggplot() +
geom_raster(aes(x = x, y = y, fill = value)) +
geom_sf(data = st_as_sf(nps), col = "white", fill = NA) +
geom_sf_text(data = st_as_sf(nps), aes(label = ParkName), col = "white"
, nudge_y = 10, size = 3) +
geom_sf(data = st_as_sf(ext_move), col = "red", fill = NA, lty = 2) +
facet_wrap("covariate") +
scale_fill_viridis_c(option = "magma") +
theme_minimal() +
coord_sf()
################################################################################
#### Simulate Dispersers
################################################################################
# Based on the derived selection coefficients, we can now simulate dispersers
formula <- ~ elev + dist + cos_ta
prefs     <- beta$Estimate
sl_dist   <- sl_dist
ta_dist   <- ta_dist
n_rsteps  <- 25
n_steps   <- 200
stop      <- F
# Let's also sample a source point. This time, we will initiate 100 individuals
# within each national park
pts <- lapply(1:nrow(nps), function(x) {
spsample(nps[x, ], type = "random", n = 100)
})
pts <- do.call(rbind, pts)
pts <- coordinates(pts)
# Visualize
plot(cov[["elev"]])
points(pts, pch = 20, cex = 0.2)
################################################################################
#### Multiple Trajectories
################################################################################
# Now we expand the code from above to simulate multiple individuals (let's say
# 10). To make bookkeeping easier, we prepare a tibble.
sims <- tibble(ID = 1:nrow(pts))
# Prepare cluster
cl <- makeCluster(detectCores() - 1)
registerDoSNOW(cl)
# Prepare progressbar
pb <- txtProgressBar(max = nrow(sims), style = 3)
progress <- function(n){setTxtProgressBar(pb, n)}
opts <- list(progress = progress)
# Run the simulation
sims$simulations <- foreach(x = 1:nrow(sims), .packages = "raster", .options.snow = opts) %dopar% {
move(
xy       = rbind(pts[x, ])
, covars   = cov
, formula  = formula
, prefs    = prefs
, sl_dist  = sl_dist
, ta_dist  = ta_dist
, ext      = ext_move
, n_steps  = n_steps
, n_rsteps = n_rsteps
, stop     = stop
)
}
# Close cluster
registerDoSEQ()
stopCluster(cl)
################################################################################
#### Cleaning and Visualizing Simulations
################################################################################
# Unnest the simulations
sims <- sims %>% unnest(simulations)
# Visualize them
ids <- unique(sims$ID)
plot(cov[["elev"]], asp = 1.03)
for (i in 1:length(unique(sims$ID))){
sub <- subset(sims, ID == ids[i])
points(sub$y ~ sub$x, col = i, pch = 16, cex = 0.4)
lines(sub$y ~ sub$x, col = i, lwd = 0.3)
}
# Store simulations
write_rds(sims, "99_SimulatedMovements.rds")
################################################################################
#### Connectivity Maps
################################################################################
# Description: We now make use of the simulated dispersal trajectories to derive
# a set of connectivity maps. This includes a heatmap, a betweenness map, and a
# map of inter-patch connectivity.
# Clear R's brain
rm(list = ls())
# Load required packages
library(tidyverse)      # For data wrangling
library(raster)         # To handle spatial data
library(viridis)        # For nice colors
library(rgdal)          # To load shapefiles
library(rgeos)          # For geometry manipulation
library(sf)             # To plot spatial things with ggplot
library(spatstat)       # To quickly rasterize (and count) spatial lines
library(maptools)       # To quickly rasterize (and count) spatial lines
library(igraph)         # For network analysis
library(ggpubr)         # To arrange multiple ggplots
library(ggnetwork)      # To plot a network using ggplot
# # Set working directory
# setwd("/home/david/ownCloud/DispersalSimulation")
# Load custom functions
source("00_Functions.R")
# Load covariate layers and simulated movements
cov <- read_rds("99_CovariateLayers.rds")
nps <- read_rds("99_NationalParks.rds")
sims <- read_rds("99_SimulatedMovements.rds")
# Create a polygon for the extent of the study area
ext <- extent(extent(0, 100, 0, 100))
ext <- as(ext, "SpatialPolygons")
################################################################################
#### Heatmap
################################################################################
# In order to generate a heatmap, we first need to convert all trajectories into
# proper spatial lines. So let's go through each simulated individual and
# convert its coordinates into a spatial line
tracks <- lapply(unique(sims$ID), function(x) {
sub <- sims[sims$ID == x, ]
coordinates(sub) <- c("x", "y")
lines <- spLines(sub)
return(lines)
})
tracks <- do.call(rbind, tracks)
tracks$ID <- 1:length(tracks)
# Visualize them
plot(cov[["elev"]])
plot(tracks, add = T, col = tracks$ID)
# Create an empty raster onto which we can rasterize the lines. I'll use the
# covariate raster as reference
heatmap <- raster(cov)
# Rasterize and count the tracks (we use a custom function that is much quicker
# than raster::rasterize(... fun = "count"))
heatmap <- rasterizeSpatstat(tracks, heatmap)
# Crop the layer to the main study area
heatmap <- crop(heatmap, ext)
# Plot the resulting heatmap
plot_heatmap <- ggplot(as.data.frame(heatmap, xy = T)) +
geom_raster(aes(x = x, y = y, fill = layer)) +
geom_sf(data = st_as_sf(nps), col = "white", fill = NA) +
scale_fill_viridis(option = "magma", name = "Traversal Frequency") +
theme_minimal() +
theme(legend.position = "bottom") +
ggtitle("Heatmap") +
coord_sf()
plot_heatmap
################################################################################
#### Betweenness
################################################################################
# Overlay the study area with a regular grid (we could again use the covariate
# layer as reference, but a coarser resolution will suffice for now)
grid <- raster(ncol = 100, nrow = 100, crs = NA)
grid <- setExtent(grid, ext)
grid[] <- 1:ncell(grid)
plot(grid)
# Prepare network (the center of each grid cell is a node in the final network)
vertices <- values(grid)
lay <- as.matrix(as.data.frame(grid, xy = T)[, c(1, 2)])
# At each coordinate of the simulated trajectories we now extract the cell IDs
# from the grid (this allows us to see from which to which cell an individual
# moved)
visits <- data.frame(
ID          = sims$ID
, step_number = sims$step_number
, x           = sims$x
, y           = sims$y
, CellID      = raster::extract(grid, sims[, c("x", "y")])
)
# Now we write a function that we can use to retrieve the visitation history
# along a single trajectory. That is, the function tells us all transitions from
# one cell to another. The option "singlecount = T" ensures that re-visits are
# not counted twice.
visitHist <- function(x, singlecount = T){
transitions <- data.frame(from = lag(x), to = x) %>%
group_by(from, to) %>%
na.omit() %>%
summarize(TotalConnections = n(), .groups = "drop")
if (singlecount){
transitions$TotalConnections = 1
}
return(transitions)
}
# Try what it does!
visitHist(c(1, 2, 2, 2, 3, 1), singlecount = T)
visitHist(c(1, 2, 2, 2, 3, 1), singlecount = F)
# We now want to retrieve the visitation history for each individual. For this,
# we first nest the data on visits
visits <- visits %>% nest(data = -ID)
# Then apply the function
visits <- mutate(visits, history = map(data, function(x){
visitHist(x$CellID, singlecount = T)
}))
# Let's check the visitation history of one of the individuals
visits$history[[1]]
# Summarize across individuals
history <- visits %>%
dplyr::select(ID, history) %>%
unnest(history) %>%
group_by(from, to) %>%
summarize(TotalConnections = sum(TotalConnections), .groups = "drop") %>%
ungroup() %>%
mutate(weight = mean(TotalConnections) / TotalConnections)
# Use this to compute (weighted) betweenness
net <- graph_from_data_frame(history, vertices = vertices)
is.weighted(net)
# Calculate betweenness and put the resulting values into a raster
betweenness <- grid
values(betweenness) <- betweenness(net)
# Crop the layer to the main study area
betweenness <- crop(betweenness, ext)
# Plot the betweenness (we'll make low scores better visible by applying a
# square root transformation to the color scale)
plot_betweenness <- ggplot(as.data.frame(betweenness, xy = T)) +
geom_raster(aes(x = x, y = y, fill = layer)) +
geom_sf(data = st_as_sf(nps), col = "white", fill = NA) +
scale_fill_viridis(option = "magma", name = "Betweenness", trans = "sqrt") +
theme_minimal() +
theme(legend.position = "bottom") +
ggtitle("Betweenness") +
coord_sf()
plot_betweenness
################################################################################
#### Inter-Patch Connectivity
################################################################################
# Finally, we want to visualize the relative frequency at which simulated
# individuals are moving between national parks. For this, let's give each
# national park an ID.
nps$ID <- 1:nrow(nps)
# In order to determine interpatch connectivity between national parks, we need
# to know from which national park trajectories leave and into which other
# national parks they go to. We can use the first coordinate of each simulated
# trajectory to determine from which national park the trajectory leaves
first <- subset(sims, step_number == 1)
coordinates(first) <- c("x", "y")
plot(first, pch = 20, cex = 0.3)
# Determine with which national park each startpoint intersects (can only be
# one)
from <- gIntersects(nps, first, byid = T)
from <- apply(from, 1, which)
from <- as.vector(from)
# Let's also check whith which national parks each trajectory intersects
to <- gIntersects(nps, tracks, byid = T)
to <- as.data.frame(to)
names(to) <- 1:3
# Put all into a single dataframe
inter <- cbind(first$ID, from, to)
names(inter)[1:2] <- c("ID", "from")
# Let's count how many individuals were released at each national park. Here,
# this is not too interesting as we put the same number of dispersers in each
# national park.
inter %>% count(from)
# Let's count the number of connections from one park to another
conns <- inter %>%
gather(key = to, value = reached, 3:ncol(.)) %>%
subset(reached & from != to) %>%
group_by(from, to) %>%
summarize(total_connections = n(), .groups = "drop")
# Generate network
net <- graph_from_data_frame(conns, vertices = nps$ID)
lay <- coordinates(gCentroid(nps, byid = T))
# Prepare networks for ggplotting with ggplot
net_p <- ggnetwork(net, layout = lay, arrow.gap = 1, scale = F)
# Plot the network
plot_interpatch <- ggplot(as.data.frame(cov[[1]], xy = T)) +
geom_raster(aes(x = x, y = y), fill = "black") +
geom_sf(data = st_as_sf(nps), col = "white", fill = NA) +
geom_edges(data = net_p, aes(x = x, y = y, xend = xend, yend = yend
, size = total_connections), color = magma(20)[15], curvature = 0.2
, arrow = arrow(length = unit(6, "pt"), type = "closed", angle = 30)) +
geom_nodes(data = net_p, aes(x = x, y = y), col = "white") +
scale_size_area(name = "Total Connections", max_size = 0.5, breaks = 1:5
, trans = "exp") +
theme_minimal() +
theme(legend.position = "bottom") +
ggtitle("Inter-Patch Connectivity") +
coord_sf()
plot_interpatch
################################################################################
#### Combining all Plots
################################################################################
# Remove the legends for now and rotate y-axes
p1 <- plot_heatmap + theme(legend.position = "none"
, axis.title.y = element_text(angle = 0, vjust = 0.5))
p2 <- plot_betweenness + theme(legend.position = "none"
, axis.title.y = element_text(angle = 0, vjust = 0.5))
p3 <- plot_interpatch + theme(legend.position = "none"
, axis.title.y = element_text(angle = 0, vjust = 0.5))
# Arrange the plots
p <- ggarrange(p1, p2, p3)
p
# Let's store the arranged plots to file
ggsave(plot = p, "ConnectivityPlots.png", bg = "white", width = 8, height = 8)
# Plot the betweenness (we'll make low scores better visible by applying a
# square root transformation to the color scale)
plot_betweenness <- ggplot(as.data.frame(betweenness, xy = T)) +
geom_raster(aes(x = x, y = y, fill = layer)) +
geom_sf(data = st_as_sf(nps), col = "white", fill = NA) +
scale_fill_viridis(option = "magma", name = "Betweenness") +
theme_minimal() +
theme(legend.position = "bottom") +
ggtitle("Betweenness") +
coord_sf()
plot_betweenness
################################################################################
#### Installing My Own Package
################################################################################
# Clear R's brain
rm(list = ls())
# Load required packages
library(devtools)
library(roxygen2)
################################################################################
#### riversim
################################################################################
setwd("/home/david/ownCloud/University/15. PhD/General/R-Packages")
# Create package
create("riversim")
